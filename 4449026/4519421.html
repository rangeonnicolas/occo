<div itemprop="articleBody" data-page-indentifier="/courses/initiez-vous-a-lalgebre-relationnelle-avec-le-langage-sql/lancez-votre-premiere-requete-avec-select-from-et-where" class="js-isRestrictablePage js-course-container js-smilize js-userCanWatchVideo">
<div class="userContent js-userContent">
<video id="r-4709432" src="https://vimeo.com/album/233479466">
<a href="https://vimeo.com/album/233479466">
https://vimeo.com/album/233479466</a>
</video>
<p id="r-4552796" >
Voyons voir à quoi ressemble une requête SQL de type SELECT :</p>
<pre id="r-4552797" >
<code data-claire-semantic="sql">
SELECT * FROM entity ;</code>
</pre>
<p id="r-4615351" >
Vous vous souvenez que le SQL permet de communiquer avec le SGBDR. On communique avec lui grâce à des<strong>
requêtes</strong>
. Les requêtes qui commencent par<code data-claire-semantic="text">
SELECT</code>
sont en fait des questions que l'on pose. Quand le SGBDR nous répond, on dit qu'il<strong>
renvoie</strong>
(ou<strong>
retourne</strong>
) une table.</p>
<p id="r-4552798" >
Lorsque nous<strong>
écrivons</strong>
puis<strong>
exécutons</strong>
cette requête, le SGBDR renvoie tout simplement la table<strong>
entity</strong>
, avec toutes ses lignes et toutes ses colonnes.</p>
<aside id="r-4552801" data-claire-semantic="warning">
<p id="r-4552799" >
En<strong>
algèbre relationnelle</strong>
, il n'y a pas de<strong>
doublons</strong>
dans les relations. Mais dans les<strong>
bases de données</strong>
, il peut y avoir des doublons dans une table (c'est-à-dire de lignes identiques). Si vous souhaitez éliminer les doublons d'un résultat d'une requête SQL, il faut utiliser<code data-claire-semantic="text">
SELECT DISTINCT</code>
au lieu de<code data-claire-semantic="text">
SELECT</code>
. Nous en avions déjà parlé<a href="/courses/initiez-vous-a-lalgebre-relationnelle-avec-le-langage-sql/ne-perdez-pas-de-vue-vos-cles#r-4629016">
précédemment</a>
.</p>
<pre id="r-4552800" >
<code data-claire-semantic="sql">
SELECT DISTINCT * FROM entity ;</code>
</pre>
</aside>
<p id="r-4552802" >
A partir de cette structure de base, nous allons pouvoir effectuer toutes les opérations de l'algèbre relationnelle que nous avons vues précédemment.</p>
<p id="r-4552803" >
C'est parti ! Commençons avec la projection. :)</p>
<p id="r-4579816" >
</p>
<h3 id="r-4552808" >
La projection</h3>
<p id="r-4552804" >
La projection, c'est l'affaire du mot clé<code data-claire-semantic="text">
SELECT</code>
. C'est lui qui sera chargé de sélectionner les colonnes que vous souhaitez afficher.</p>
<p id="r-4552805" >
Pour le moment, nous avons mis le caractère<code data-claire-semantic="text">
*</code>
derrière le<code data-claire-semantic="text">
SELECT</code>
. Cette étoile signifie que nous souhaitons obtenir toutes les colonnes disponibles.</p>
<p id="r-4552806" >
Nous pouvons cependant remplacer ce caractère par les colonnes que nous souhaitons. Voici un exemple :</p>
<pre id="r-4552807" >
<code data-claire-semantic="sql">
SELECT id, name, status FROM entity ;</code>
</pre>
<p id="r-4569136" >
Allez-y, testez par vous-même dans la console en bas de ce chapitre !</p>
<p id="r-4579817" >
</p>
<h3 id="r-4552880" >
La restriction</h3>
<p id="r-4552809" >
Vous vous souvenez que la restriction consiste à ne sélectionner que certaines lignes de la table selon une condition.</p>
<p id="r-4552810" >
Pour faire cela, nous spécifions cette condition grâce au mot clé<code data-claire-semantic="text">
WHERE</code>
.</p>
<p id="r-4552811" >
Commençons notre investigation ! Nous allons rechercher notre mystérieuse société dont le nom est<em>
Big Data Crunchers Ltd</em>
.</p>
<pre id="r-4552812" >
<code data-claire-semantic="sql">
SELECT * FROM entity WHERE name = 'Big Data Crunchers Ltd.' ;</code>
</pre>
<p id="r-4552813" >
Cette requête renvoie une table d'une ligne, qui correspond à la société que nous recherchons.</p>
<aside id="r-4552815" data-claire-semantic="information">
<p id="r-4552814" >
Dans cette requête, nous avons utilisé le signe<code data-claire-semantic="text">
<strong>
=</strong>
</code>
, qui teste si la variable<code data-claire-semantic="text">
name</code>
et la chaîne<code data-claire-semantic="text">
'Big Data Crunchers Ltd.'</code>
ont la même valeur.</p>
</aside>
<p id="r-4552816" >
D'autres opérateurs sont possibles en SQL :</p>
<ul id="r-4552819" >
<li id="r-4552818" >
<p id="r-4552817" >
Les opérateurs de comparaison :</p>
</li>
</ul>
<table id="r-4552866" >
<tbody id="r-4552865" >
<tr id="r-4552824" >
<td id="r-4552821" >
<p id="r-4552820" >
<strong>
Opérateur</strong>
</p>
</td>
<td id="r-4552823" >
<p id="r-4552822" >
<strong>
Teste si ...</strong>
</p>
</td>
</tr>
<tr id="r-4552829" >
<td id="r-4552826" >
<p id="r-4552825" >
<code data-claire-semantic="text">
A = B</code>
</p>
</td>
<td id="r-4552828" >
<p id="r-4552827" >
A égal à B</p>
</td>
</tr>
<tr id="r-4552834" >
<td id="r-4552831" >
<p id="r-4552830" >
<code data-claire-semantic="text">
A &lt;&gt; B</code>
</p>
</td>
<td id="r-4552833" >
<p id="r-4552832" >
A différent de B</p>
</td>
</tr>
<tr id="r-4552839" >
<td id="r-4552836" >
<p id="r-4552835" >
<code data-claire-semantic="text">
A &gt; B</code>
et<code data-claire-semantic="text">
A &lt; B</code>
</p>
</td>
<td id="r-4552838" >
<p id="r-4552837" >
A supérieur à B / A inférieur à B</p>
</td>
</tr>
<tr id="r-4552844" >
<td id="r-4552841" >
<p id="r-4552840" >
<code data-claire-semantic="text">
A &gt;= B</code>
et<code data-claire-semantic="text">
A &lt;= B</code>
</p>
</td>
<td id="r-4552843" >
<p id="r-4552842" >
A supérieur ou égal à B / A inférieur ou égal à B</p>
</td>
</tr>
<tr id="r-4552849" >
<td id="r-4552846" >
<p id="r-4552845" >
<code data-claire-semantic="text">
A BETWEEN B AND C</code>
</p>
</td>
<td id="r-4552848" >
<p id="r-4552847" >
A est compris entre B et C</p>
</td>
</tr>
<tr id="r-4552854" >
<td id="r-4552851" >
<p id="r-4552850" >
<code data-claire-semantic="text">
A LIKE 'chaîne de caractères'</code>
</p>
</td>
<td id="r-4552853" >
<p id="r-4552852" >
(nous verrons cet opérateur dans un prochain chapitre)</p>
</td>
</tr>
<tr id="r-4552859" >
<td id="r-4552856" >
<p id="r-4552855" >
<code data-claire-semantic="text">
A IN (B1, B2, B3, etc.)</code>
</p>
</td>
<td id="r-4552858" >
<p id="r-4552857" >
A est présent dans la liste (B1, B2, etc.)</p>
</td>
</tr>
<tr id="r-4552864" >
<td id="r-4552861" >
<p id="r-4552860" >
<code data-claire-semantic="text">
A IS NULL</code>
</p>
</td>
<td id="r-4552863" >
<p id="r-4552862" >
A n'a pas de valeur</p>
</td>
</tr>
</tbody>
</table>
<ul id="r-4552876" >
<li id="r-4552875" >
<p id="r-4552867" >
Les opérateurs logiques :</p>
<ul id="r-4552874" >
<li id="r-4552869" >
<p id="r-4552868" >
<code data-claire-semantic="text">
OR</code>
</p>
</li>
<li id="r-4552871" >
<p id="r-4552870" >
<code data-claire-semantic="text">
AND</code>
</p>
</li>
<li id="r-4552873" >
<p id="r-4552872" >
<code data-claire-semantic="text">
NOT</code>
</p>
</li>
</ul>
</li>
</ul>
<p id="r-4579941" >
Ils signifient respectivement OU, ET, NON.</p>
<p id="r-4552877" >
Grâce à ces opérateurs, on peut complexifier un peu notre condition :</p>
<pre id="r-4552878" >
<code data-claire-semantic="sql">
SELECT * FROM entity WHERE (id &lt; 10000004 AND (NOT id &lt; 10000000)) OR (name = 'Big Data Crunchers Ltd.');</code>
</pre>
<p id="r-4552879" >
Cette requête affichera toutes les sociétés dont l'identifiant est compris entre 10000000 (inclus) et 10000004 (non inclus) ainsi que toutes les sociétés dont le nom est<code data-claire-semantic="text">
Big Data Crunchers Ltd.</code>
. Relisez à tête reposée, c'est de la gymnastique de neurones ! ^^</p>
<p id="r-4579818" >
</p>
<h3 id="r-4552892" >
Le produit cartésien</h3>
<p id="r-4552881" >
Pour effectuer le produit cartésien entre deux tables, il faut simplement spécifier ces deux tables derrière la clause<code data-claire-semantic="text">
FROM</code>
. Rien de plus simple !</p>
<pre id="r-4552882" >
<code data-claire-semantic="sql">
SELECT * FROM entity, address ;</code>
</pre>
<p id="r-4569137" >
Vous pouvez même spécifier plus de 2 tables ! Le résultat sera ainsi l'ensemble des combinaisons possibles entre toutes les lignes de chacune des tables.</p>
<aside id="r-4569139" data-claire-semantic="warning">
<p id="r-4569138" >
Cette requête peut être coûteuse en ressources (en temps de calcul et en mémoire vive). En effet, le nombre de lignes renvoyé sera égal au nombre de lignes de la table<strong>
entity</strong>
multiplié par le nombre de lignes de<strong>
address</strong>
. Prenez garde, ce nombre peut vite exploser !</p>
<p id="r-4705092" >
Dans la console interactive, il est d'ailleurs possible que cette requête bogge.</p>
</aside>
<div id="r-4552887" data-claire-semantic="question">
<p id="r-4552886" >
Peut-on omettre<code data-claire-semantic="text">
FROM</code>
?</p>
</div>
<p id="r-4552888" >
Bonne question !</p>
<p id="r-4552889" >
Une requête sans le mot clé<code data-claire-semantic="text">
FROM</code>
est une requête qui ne se fait sur aucune table. Elle ne renvoie donc qu'une seule ligne. Par exemple, la requête suivante :</p>
<pre id="r-4552890" >
<code data-claire-semantic="sql">
SELECT 45, 20, 'bonjour' ;</code>
</pre>
<p id="r-4552891" >
renvoie une ligne composée de 3 attributs (donc 3 colonnes). La valeur de ceux-ci sera<code data-claire-semantic="text">
45</code>
,<code data-claire-semantic="text">
20</code>
et<code data-claire-semantic="text">
bonjour</code>
.</p>
<p id="r-4615356" >
</p>
<h3 id="r-4552922" >
Projections : les fonctions scalaires, et le mot clé AS</h3>
<p id="r-4552896" >
Il est possible d'appliquer des<strong>
fonctions</strong>
sur les colonnes. Par exemple, nous pouvons utiliser la fonction multiplication, en multipliant l'identifiant de toutes les entités par 2 (et pourquoi pas ?).</p>
<pre id="r-4552897" >
<code data-claire-semantic="sql">
SELECT id * 2, name, status FROM entity ;</code>
</pre>
<p id="r-4552898" >
Il est même possible de combiner des fonctions. Par exemple, calculons la valeur absolue de l'opposé de l'identifiant multiplié par 2 (soyons fous !) : o_O</p>
<pre id="r-4552899" >
<code data-claire-semantic="sql">
SELECT ABS( (- id) *2 ) AS calcul_bizarre, name, status FROM entity ;</code>
</pre>
<aside id="r-4552901" data-claire-semantic="warning">
<p id="r-4552900" >
Ici, j'ai utilisé le mot clé<code data-claire-semantic="text">
AS</code>
. Il permet de renommer une colonne. Sans ce mot clé, la colonne résultat du calcul mathématique aurait comme nom "ABS((-id)*2)", ce qui n'est pas très compréhensible ! je l'ai donc renommée en "calcul_bizarre".</p>
</aside>
<p id="r-4552902" >
Il existe beaucoup de types de fonctions ! Par exemple, des fonctions sur des chaînes de caractères. Si on souhaite obtenir le nom d'une société et ajouter à cette chaîne son statut entre parenthèses, on peut utiliser l'opérateur de concaténation<code data-claire-semantic="text">
||</code>
:</p>
<pre id="r-4552903" >
<code data-claire-semantic="sql">
SELECT name || '(' || status || ')' AS name_and_status FROM entity ; -- Version Mysql (pour la console interactive): SELECT concat(name,'(',status,')') AS name_and_status FROM entity ;</code>
</pre>
<p id="r-4552904" >
Il y a également des fonctions utilisant des dates, ou des fonctions binaires (qui renvoient<code data-claire-semantic="text">
TRUE</code>
ou<code data-claire-semantic="text">
FALSE</code>
). Voici un exemple :</p>
<pre id="r-4552905" >
<code data-claire-semantic="sql">
SELECT CURRENT_DATE() &gt; incorporation_date FROM entity ;</code>
</pre>
<p id="r-4552906" >
Ici,<code data-claire-semantic="text">
CURRENT_DATE()</code>
renvoie la date actuelle. Celle-ci est ensuite comparée à l'attribut<code data-claire-semantic="text">
incorporation_date</code>
grâce à l'opérateur<code data-claire-semantic="text">
&gt;</code>
, qui renvoie<code data-claire-semantic="text">
TRUE</code>
(ou<code data-claire-semantic="text">
1</code>
selon votre SGBD) si incorporation_date est antérieure à la date actuelle,<code data-claire-semantic="text">
FALSE</code>
(ou<code data-claire-semantic="text">
0</code>
) sinon.</p>
<p id="r-4552907" >
</p>
<h3 id="r-4637453" >
Un peu d'entraînement !</h3>
<p id="r-4637451" >
La base de données est en ligne, vous pouvez vous entraîner en réécrivant les requêtes de ce chapitre. N'hésitez pas à les modifier, à jouer avec, pour "voir ce que ça fait". ;)</p>
<p id="r-4637452" >
<a href="https://www.codevolve.com/api/v1/publishable_key/2A9CAA3419124E3E8C3F5AFCE5306292?content_id=ba014daa-d108-4e91-83f1-42154313b2d1">
Console interactive</a>
</p>
</div>
<div class="js-courseSelementActions sideActions">
<ul class="sideActions__container">
<li>
<a class="sideActions__item js-courseElementActions-copyUrl js-tooltip" href="#" data-tooltip="Copier le lien" data-tooltip-done="Lien copié !">
#</a>
</li>
</ul>
</div>
</div>
